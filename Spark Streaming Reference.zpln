{
  "paragraphs": [
    {
      "text": "%md\n# Spark Structured Streaming\n\nSpark Structured Streaming offers query processing over dataframes in a streaming fashion. \n\nBefore you start, read the excellent [introduction to Spark Structured Streaming](https://spark.apache.org/docs/latest/structured-streaming-programming-guide.html).\nThe lab session assumes that you viewed the Structured Streaming lecture and studied the background literature.\n\nThe exercise uses the abstractions offered by Spark to analyze the data from an online marketplace inspired by a popular online gam[e](https://www.youtube.com/watch?v=BJhF0L7pfo8).\nIn that game:\n\n+ players sell various items; whenever an item is sold the transaction is reported;\n+ every item has a material (e.g., Iron, Steel), a type (Sword, Shield), and a price;\n+ in order to get live updates on the economy, a Spark Streaming application would be perfect.\n\nJust like the previous lab sessions, work through the notebook by answering the questions posed, and implementing various features for your ideal game dashboard. \nUse the questions and the code you wrote as the basis for your blog post.\n\n**Note up-front:**\n_Stream processing is non-trivial, especially when while working on your assignment, you may be restarting streams etc. when things went wrong.\nA common consequence is the Docker container running out of memory, or the Zeppelin notebook seemingly \"getting stuck\".\nTry to stop the container, and then start it again; you may also have to remove state in the form of data directories or checkpoint directories.\nThis procedure tends to resolve inexplicable problems I encountered while developing this new lab session (say in 99% of the cases)._",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h1>Spark Structured Streaming</h1>\n<p>Spark Structured Streaming offers query processing over dataframes in a streaming fashion.</p>\n<p>Before you start, read the excellent <a href=\"https://spark.apache.org/docs/latest/structured-streaming-programming-guide.html\">introduction to Spark Structured Streaming</a>.<br />\nThe lab session assumes that you viewed the Structured Streaming lecture and studied the background literature.</p>\n<p>The exercise uses the abstractions offered by Spark to analyze the data from an online marketplace inspired by a popular online gam<a href=\"https://www.youtube.com/watch?v=BJhF0L7pfo8\">e</a>.<br />\nIn that game:</p>\n<ul>\n<li>players sell various items; whenever an item is sold the transaction is reported;</li>\n<li>every item has a material (e.g., Iron, Steel), a type (Sword, Shield), and a price;</li>\n<li>in order to get live updates on the economy, a Spark Streaming application would be perfect.</li>\n</ul>\n<p>Just like the previous lab sessions, work through the notebook by answering the questions posed, and implementing various features for your ideal game dashboard.<br />\nUse the questions and the code you wrote as the basis for your blog post.</p>\n<p><strong>Note up-front:</strong><br />\n<em>Stream processing is non-trivial, especially when while working on your assignment, you may be restarting streams etc. when things went wrong.<br />\nA common consequence is the Docker container running out of memory, or the Zeppelin notebook seemingly &ldquo;getting stuck&rdquo;.<br />\nTry to stop the container, and then start it again; you may also have to remove state in the form of data directories or checkpoint directories.<br />\nThis procedure tends to resolve inexplicable problems I encountered while developing this new lab session (say in 99% of the cases).</em></p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769657_138085392",
      "id": "paragraph_1589448209034_2145197905",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "focus": true,
      "$$hashKey": "object:105"
    },
    {
      "text": "%md\n## Using Zeppelin\n\nWe have switched from Spark Notebook to Apache Zeppelin, as the former does not receive support any longer. \n\nEvery notebook has a default interpreter, Spark in our case; so, new empty cells correspond to Spark programs. \nZeppelin supports multiple interpreters, e.g., this instruction is written in Markdown using a cell that starts \nwith `%md` to select the Markdown interpreter instead of the default Spark interpreter. We have hidden the input \nto make the notebook look nicer; you can modify these settings using the menu on the top right of each cell.\n\nWhat you should also know: the `%sh` shell interpreter let's you execute shell commands from within the notebook.\nE.g. if you wish to wipe data written into a directory `/bigdata` (to prepare for a new sample from the stream\nlater on in the lab session), you would simply create a cell with this input:\n\n```\n%sh\nrm -rf /bigdata/*\n```\n\n_If you need more help:_\nthe [Hortonworks documentation](https://docs.cloudera.com/HDPDocuments/HDP3/HDP-3.1.5/using-zeppelin/content/working_with_notes.html) gives a nice and brief introduction into all features of the Zeppelin UI/UX.",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h2>Using Zeppelin</h2>\n<p>We have switched from Spark Notebook to Apache Zeppelin, as the former does not receive support any longer.</p>\n<p>Every notebook has a default interpreter, Spark in our case; so, new empty cells correspond to Spark programs.<br />\nZeppelin supports multiple interpreters, e.g., this instruction is written in Markdown using a cell that starts<br />\nwith <code>%md</code> to select the Markdown interpreter instead of the default Spark interpreter. We have hidden the input<br />\nto make the notebook look nicer; you can modify these settings using the menu on the top right of each cell.</p>\n<p>What you should also know: the <code>%sh</code> shell interpreter let&rsquo;s you execute shell commands from within the notebook.<br />\nE.g. if you wish to wipe data written into a directory <code>/bigdata</code> (to prepare for a new sample from the stream<br />\nlater on in the lab session), you would simply create a cell with this input:</p>\n<pre><code>%sh\nrm -rf /bigdata/*\n</code></pre>\n<p><em>If you need more help:</em><br />\nthe <a href=\"https://docs.cloudera.com/HDPDocuments/HDP3/HDP-3.1.5/using-zeppelin/content/working_with_notes.html\">Hortonworks documentation</a> gives a nice and brief introduction into all features of the Zeppelin UI/UX.</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769659_-1039162800",
      "id": "paragraph_1589452403808_1091206130",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:106"
    },
    {
      "text": "%md\n## Input Stream\n\nWe created a sample python program that writes the [RuneScape](https://runescape.com) \"like\" output to port 9999. \n\nFor the sake of the assignment, you will start the stream inside the course container (of course, you'd be reading from an internet connection \nin a real life application of Spark Structured Streaming, probably using a Kafka input source, but we keep things simple for now).\n\nStart the sample stream as follows (_try to understand what happens_):\n\n    docker cp stream.py snbz:/\n    docker exec snbz sh -c \"python stream.py &\"\n\nFinally, we are ready to use Spark Structured Streaming to process the stream into a dashboard.",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h2>Input Stream</h2>\n<p>We created a sample python program that writes the <a href=\"https://runescape.com\">RuneScape</a> &ldquo;like&rdquo; output to port 9999.</p>\n<p>For the sake of the assignment, you will start the stream inside the course container (of course, you&rsquo;d be reading from an internet connection<br />\nin a real life application of Spark Structured Streaming, probably using a Kafka input source, but we keep things simple for now).</p>\n<p>Start the sample stream as follows (<em>try to understand what happens</em>):</p>\n<pre><code>docker cp stream.py snbz:/\ndocker exec snbz sh -c &quot;python stream.py &amp;&quot;\n</code></pre>\n<p>Finally, we are ready to use Spark Structured Streaming to process the stream into a dashboard.</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769659_-1909410254",
      "id": "paragraph_1590346737403_-1899530057",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:107"
    },
    {
      "text": "%md\n## Preliminaries\nStart with a few imports:",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h2>Preliminaries</h2>\n<p>Start with a few imports:</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769659_-1920781680",
      "id": "paragraph_1590373097354_-1345560625",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:108"
    },
    {
      "text": "// A few imports we need later on:\nimport spark.implicits._\nimport spark.sqlContext.implicits._\nimport org.apache.spark.sql._\nimport org.apache.spark.sql.types.{DataType, DateType, TimestampType}\nimport org.apache.spark.sql.streaming.Trigger",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T10:03:36+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "import spark.implicits._\nimport spark.sqlContext.implicits._\nimport org.apache.spark.sql._\nimport org.apache.spark.sql.types.{DataType, DateType, TimestampType}\nimport org.apache.spark.sql.streaming.Trigger\n"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769659_-154000568",
      "id": "paragraph_1590373001011_1107059707",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "dateStarted": "2020-06-07T10:03:36+0000",
      "dateFinished": "2020-06-07T10:03:36+0000",
      "status": "FINISHED",
      "$$hashKey": "object:109"
    },
    {
      "text": "%md\nCreate a dataframe tied to the TCP/IP stream on localhost port 9999 using the `readStream` operation:",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Create a dataframe tied to the TCP/IP stream on localhost port 9999 using the <code>readStream</code> operation:</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769659_155932156",
      "id": "paragraph_1589448302509_1503843353",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:110"
    },
    {
      "text": "val socketDF = spark.readStream\n  .format(\"socket\")\n  .option(\"host\", \"0.0.0.0\")\n  .option(\"port\", 9999)\n  .load()",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T10:03:43+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "\u001b[1m\u001b[34msocketDF\u001b[0m: \u001b[1m\u001b[32morg.apache.spark.sql.DataFrame\u001b[0m = [value: string]\n"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769660_-1530089121",
      "id": "paragraph_1589445007354_1672367834",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "dateStarted": "2020-06-07T10:03:43+0000",
      "dateFinished": "2020-06-07T10:03:43+0000",
      "status": "FINISHED",
      "$$hashKey": "object:111"
    },
    {
      "text": "%md\nWhile the result looks like an ordinary DataFrame at first sight, it identifies itself as a _Streaming Dataframe_ when you check:",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>While the result looks like an ordinary DataFrame at first sight, it identifies itself as a <em>Streaming Dataframe</em> when you check:</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769660_-674395229",
      "id": "paragraph_1589968457518_487118191",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:112"
    },
    {
      "text": "socketDF.isStreaming",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "\u001b[1m\u001b[34mres1\u001b[0m: \u001b[1m\u001b[32mBoolean\u001b[0m = true\n"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769660_1749456133",
      "id": "paragraph_1589449282216_1888903424",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:113"
    },
    {
      "text": "%md\n## In-memory stream processing\nKeep in mind that Spark has a lazy execution paradigm; nothing has actually happened this far.\n\nLet's move on and write a sample of data from the TCP/IP connection into an in-memory dataframe for further analysis.",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h2>In-memory stream processing</h2>\n<p>Keep in mind that Spark has a lazy execution paradigm; nothing has actually happened this far.</p>\n<p>Let&rsquo;s move on and write a sample of data from the TCP/IP connection into an in-memory dataframe for further analysis.</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769660_1967327007",
      "id": "paragraph_1590346108921_-205119332",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:114"
    },
    {
      "text": "// Setup streamreader\nval streamWriterMem = socketDF\n  .writeStream\n  .outputMode(\"append\")\n  .format(\"memory\")",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "editorHide": false,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769660_-1619930606",
      "id": "paragraph_1589445076331_1204507247",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:115"
    },
    {
      "text": "// Start streaming!\nval memoryQuery = streamWriterMem  \n  .queryName(\"memoryDF\")\n  .start()\n\n// Run for 1 second...\nmemoryQuery\n  .awaitTermination(1000)\n  \n// ... and stop the query, to avoid filling up memory:\nmemoryQuery\n  .stop()",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "editorHide": false,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769661_-587831729",
      "id": "paragraph_1590347143256_1052199518",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:116"
    },
    {
      "text": "%md\nThe `memoryQuery` is a `StreamingQuery`, which reads data from a TCP socket, and splits it into individual lines based on newlines.\n\nSince we are streaming into memory, we need to be careful not to overflow it. Streaming for only 1 second to get a feel for the data is a safe bet.\n\nThe query is tied to a Dataframe named `memoryDF` that we can analyze using SQL:",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>The <code>memoryQuery</code> is a <code>StreamingQuery</code>, which reads data from a TCP socket, and splits it into individual lines based on newlines.</p>\n<p>Since we are streaming into memory, we need to be careful not to overflow it. Streaming for only 1 second to get a feel for the data is a safe bet.</p>\n<p>The query is tied to a Dataframe named <code>memoryDF</code> that we can analyze using SQL:</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769661_-1615429287",
      "id": "paragraph_1589452113213_-1020765739",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:117"
    },
    {
      "text": "// Query the top 10 rows from the dataframe, not truncating results\nspark.sql(\"select * from memoryDF\").show(10, false)",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "editorHide": false,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769661_258706381",
      "id": "paragraph_1590347520347_1700196331",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:118"
    },
    {
      "text": "%md\nLet's see how many rows we found.",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Let&rsquo;s see how many rows we found.</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769661_-943726819",
      "id": "paragraph_1589451920089_-2103181667",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:119"
    },
    {
      "text": "spark.sql(\"select count(*) from memoryDF\").show()",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769661_-1506260256",
      "id": "paragraph_1589451990777_1216309247",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:120"
    },
    {
      "text": "%md\nYou can repeat this multiple times, every time with (slightly) different results in sample count, and different output for the `.show()` command. \n\nFeel free to vary the time you read from the stream, or execute different SQL commands. Remember that all processing is in-memory, so take care not to collect too much data though. On a real cluster, that would be less problematic, but your resources are limited to those of your own machine (or the ones in Huygens).",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>You can repeat this multiple times, every time with (slightly) different results in sample count, and different output for the <code>.show()</code> command.</p>\n<p>Feel free to vary the time you read from the stream, or execute different SQL commands. Remember that all processing is in-memory, so take care not to collect too much data though. On a real cluster, that would be less problematic, but your resources are limited to those of your own machine (or the ones in Huygens).</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769661_-2032099135",
      "id": "paragraph_1590349469263_-981939215",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:121"
    },
    {
      "text": "%md\n## Parsing the input stream\n\nSo far, we have simply copied data from the input stream into a Dataframe in memory. Now that we know the structure of the stream messages, we should transform the data from `String` into a structure that can be processed in a more meaningful way. Use a regular expression on the data read from the stream before you write it out to memory. \n\nThe hints in the comments are meant to help you get started with the regular expression you need (add another extraction) and construction of a SQL query with multiple uses of the same regex, using Scala's [string interpolation](https://docs.scala-lang.org/overviews/core/string-interpolation.html).",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h2>Parsing the input stream</h2>\n<p>So far, we have simply copied data from the input stream into a Dataframe in memory. Now that we know the structure of the stream messages, we should transform the data from <code>String</code> into a structure that can be processed in a more meaningful way. Use a regular expression on the data read from the stream before you write it out to memory.</p>\n<p>The hints in the comments are meant to help you get started with the regular expression you need (add another extraction) and construction of a SQL query with multiple uses of the same regex, using Scala&rsquo;s <a href=\"https://docs.scala-lang.org/overviews/core/string-interpolation.html\">string interpolation</a>.</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769662_-257674568",
      "id": "paragraph_1590352535980_-430940734",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:122"
    },
    {
      "text": "// Fill in the gaps!\n\n// Hint: modify the type definitions to produce RuneData as triples <material, tpe, price>\n\ncase class RuneData(material: String, price: Integer)\n\n// Hint: modify the regular expression to parse the strings taken from the stream into triples\n\nval myregex = \"\\\"^([A-Z].+) [A-Z].+ was sold for (\\\\\\\\d+)\\\"\"\nval q = f\"select regexp_extract(value, $myregex%s, 1) as material, cast(regexp_extract(value, $myregex%s, 2) as Integer) as price from memoryDF\"\nspark.sql(q).as[RuneData].show(10, false)",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769662_197475462",
      "id": "paragraph_1590352674285_961143901",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:123"
    },
    {
      "text": "%md\n## Stream Processing\n\nSo far, we took samples from a stream and prepared our code for parsing that stream. Let us now switch to continuous stream processing;\nfirst using console output for debugging, and subsequently writing the stream query output to disk.\n\n### Console output\n\nFinally, we will see stream-based processing in action. Let us set an update interval of 5 seconds.",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h2>Stream Processing</h2>\n<p>So far, we took samples from a stream and prepared our code for parsing that stream. Let us now switch to continuous stream processing;<br />\nfirst using console output for debugging, and subsequently writing the stream query output to disk.</p>\n<h3>Console output</h3>\n<p>Finally, we will see stream-based processing in action. Let us set an update interval of 5 seconds.</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769662_-507250943",
      "id": "paragraph_1590365012512_-2000840488",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:124"
    },
    {
      "text": "// Create and start a streaming query on the same TCP/IP input stream\nval consoleQuery = socketDF\n  .writeStream\n  .outputMode(\"append\")\n  .format(\"console\")\n  .start()",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769662_808862420",
      "id": "paragraph_1590364433946_-196295345",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:125"
    },
    {
      "text": "%md\nIssue the following cell a few times before stopping this trivial query.",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Issue the following cell a few times before stopping this trivial query.</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769662_1024503702",
      "id": "paragraph_1590365218580_651540030",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:126"
    },
    {
      "text": "spark.streams.active",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769663_-202345304",
      "id": "paragraph_1590365220818_1028967847",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:127"
    },
    {
      "text": "%md\nStop the query when you have seen enough.",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Stop the query when you have seen enough.</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769663_-157182462",
      "id": "paragraph_1590365279388_-363941900",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:128"
    },
    {
      "text": "consoleQuery.stop()",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769663_441546393",
      "id": "paragraph_1590365223536_1133035361",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:129"
    },
    {
      "text": "%md\n## Structured Output\nNow it is time to apply our previous code to parse the input stream into `RuneData`.",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T14:53:46+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h2>Structured Output</h2>\n<p>Now it is time to apply our previous code to parse the input stream into <code>RuneData</code>.</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769663_-2047657766",
      "id": "paragraph_1590365383386_-132734152",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "FINISHED",
      "$$hashKey": "object:130",
      "dateFinished": "2020-06-07T14:53:44+0000",
      "dateStarted": "2020-06-07T14:53:44+0000"
    },
    {
      "text": "socketDF\n  .withColumn(\"timestamp\",current_timestamp().as(\"timestamp\"))\n  .withWatermark(\"timestamp\",\"10 seconds\")\n  .createOrReplaceTempView(\"runeUpdatesDF\")",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T18:17:24+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769663_1127738516",
      "id": "paragraph_1590366117502_-920559067",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "dateStarted": "2020-06-04T18:17:24+0000",
      "dateFinished": "2020-06-04T18:17:24+0000",
      "status": "FINISHED",
      "$$hashKey": "object:131"
    },
    {
      "text": "case class RuneData(material: String, tpe: String, price: Integer)\n\nimplicit val enc: Encoder[RuneData] = Encoders.product[RuneData]\n\nval myregex = \"\\\"^([A-Z].+) ([A-Z].+) was sold for (\\\\\\\\d+)\\\"\"\nval q = f\"select timestamp as timestamp, regexp_extract(value, $myregex%s, 1) as material, regexp_extract(value, $myregex%s, 2) as tpe, cast(regexp_extract(value, $myregex%s, 3) as Integer) as price from runeUpdatesDF\"\nspark.sql(q).as[RuneData].createOrReplaceTempView(\"runes\")",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T18:17:26+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "defined class RuneData\n\u001b[1m\u001b[34menc\u001b[0m: \u001b[1m\u001b[32morg.apache.spark.sql.Encoder[RuneData]\u001b[0m = class[material[0]: string, tpe[0]: string, price[0]: int]\n\u001b[1m\u001b[34mmyregex\u001b[0m: \u001b[1m\u001b[32mString\u001b[0m = \"^([A-Z].+) ([A-Z].+) was sold for (\\\\d+)\"\n\u001b[1m\u001b[34mq\u001b[0m: \u001b[1m\u001b[32mString\u001b[0m = select timestamp as timestamp, regexp_extract(value, \"^([A-Z].+) ([A-Z].+) was sold for (\\\\d+)\", 1) as material, regexp_extract(value, \"^([A-Z].+) ([A-Z].+) was sold for (\\\\d+)\", 2) as tpe, cast(regexp_extract(value, \"^([A-Z].+) ([A-Z].+) was sold for (\\\\d+)\", 3) as Integer) as price from runeUpdatesDF\n"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769663_-458067417",
      "id": "paragraph_1590363637302_1990183194",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "dateStarted": "2020-06-04T18:17:26+0000",
      "dateFinished": "2020-06-04T18:17:26+0000",
      "status": "FINISHED",
      "$$hashKey": "object:132"
    },
    {
      "text": "// What we want to display on the dashboard\nval r  = spark.sql(\"select timestamp, material, price from runes\")\nval rc = spark.sql(\"select timestamp, material, avg(price) as average from runes group by material,timestamp\")\n//rc.createOrReplaceTempView(\"runecounts\")",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T18:36:54+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "\u001b[1m\u001b[34mr\u001b[0m: \u001b[1m\u001b[32morg.apache.spark.sql.DataFrame\u001b[0m = [timestamp: timestamp, material: string ... 1 more field]\n\u001b[1m\u001b[34mrc\u001b[0m: \u001b[1m\u001b[32morg.apache.spark.sql.DataFrame\u001b[0m = [timestamp: timestamp, material: string ... 1 more field]\n"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769664_2064958755",
      "id": "paragraph_1591041806866_-784598459",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "dateStarted": "2020-06-04T18:36:54+0000",
      "dateFinished": "2020-06-04T18:36:54+0000",
      "status": "FINISHED",
      "$$hashKey": "object:133"
    },
    {
      "text": "// Lineitems\nval rq = r\n  .writeStream\n  .outputMode(\"append\")\n  .format(\"memory\")\n  .queryName(\"rQ\")\n  .trigger(Trigger.ProcessingTime(\"10 seconds\"))\n  .start()\n\n// Aggregations\nval rcqa = rc\n  .writeStream\n  .outputMode(\"append\")\n  .format(\"memory\")\n  .queryName(\"rcQa\")\n  .trigger(Trigger.ProcessingTime(\"10 seconds\"))\n  .start()\n\nval rcqc = rc\n  .writeStream\n  .outputMode(\"complete\")\n  .format(\"memory\")\n  .queryName(\"rcQc\")\n  .trigger(Trigger.ProcessingTime(\"10 seconds\"))\n  .start()",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T18:54:13+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "\u001b[1m\u001b[34mrq\u001b[0m: \u001b[1m\u001b[32morg.apache.spark.sql.streaming.StreamingQuery\u001b[0m = org.apache.spark.sql.execution.streaming.StreamingQueryWrapper@4d3bba71\n\u001b[1m\u001b[34mrcqa\u001b[0m: \u001b[1m\u001b[32morg.apache.spark.sql.streaming.StreamingQuery\u001b[0m = org.apache.spark.sql.execution.streaming.StreamingQueryWrapper@75e0c1c7\n\u001b[1m\u001b[34mrcqc\u001b[0m: \u001b[1m\u001b[32morg.apache.spark.sql.streaming.StreamingQuery\u001b[0m = org.apache.spark.sql.execution.streaming.StreamingQueryWrapper@535c9851\n"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769664_875301093",
      "id": "paragraph_1591046577705_-260699565",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "dateStarted": "2020-06-04T18:54:13+0000",
      "dateFinished": "2020-06-04T18:54:13+0000",
      "status": "FINISHED",
      "$$hashKey": "object:134"
    },
    {
      "text": "rq.explain()\nrcqa.explain()\nrcqc.explain()",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T19:13:05+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {
          "0": {
            "graph": {
              "mode": "table",
              "height": 614,
              "optionOpen": false
            }
          }
        },
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "== Physical Plan ==\n*(2) Project [timestamp#2961-T10000ms AS timestamp#2967-T10000ms, regexp_extract(value#6340, ^([A-Z].+) ([A-Z].+) was sold for (\\d+), 1) AS material#2968, cast(regexp_extract(value#6340, ^([A-Z].+) ([A-Z].+) was sold for (\\d+), 3) as int) AS price#2970]\n+- EventTimeWatermark timestamp#2961: timestamp, interval 10 seconds\n   +- *(1) Project [value#6340, 1591296853407000 AS timestamp#2961]\n      +- *(1) Project [value#6340]\n         +- *(1) ScanV2 socket[value#6340] (Options: [host=0.0.0.0,port=9999])\n== Physical Plan ==\n*(5) HashAggregate(keys=[material#2968, timestamp#2967-T10000ms], functions=[avg(cast(price#2970 as bigint))])\n+- StateStoreSave [material#2968, timestamp#2967-T10000ms], state info [ checkpoint = file:/tmp/temporary-502ccc3f-107a-4c9e-bf9a-9c900914595c/state, runId = 3dcc185d-9cf1-4d0c-b76e-5517cb054c05, opId = 0, ver = 0, numPartitions = 200], Append, 0, 2\n   +- *(4) HashAggregate(keys=[material#2968, timestamp#2967-T10000ms], functions=[merge_avg(cast(price#2970 as bigint))])\n      +- StateStoreRestore [material#2968, timestamp#2967-T10000ms], state info [ checkpoint = file:/tmp/temporary-502ccc3f-107a-4c9e-bf9a-9c900914595c/state, runId = 3dcc185d-9cf1-4d0c-b76e-5517cb054c05, opId = 0, ver = 0, numPartitions = 200], 2\n         +- *(3) HashAggregate(keys=[material#2968, timestamp#2967-T10000ms], functions=[merge_avg(cast(price#2970 as bigint))])\n            +- Exchange hashpartitioning(material#2968, timestamp#2967-T10000ms, 200)\n               +- *(2) HashAggregate(keys=[material#2968, timestamp#2967-T10000ms], functions=[partial_avg(cast(price#2970 as bigint))])\n                  +- *(2) Project [timestamp#2961-T10000ms AS timestamp#2967-T10000ms, regexp_extract(value#6357, ^([A-Z].+) ([A-Z].+) was sold for (\\d+), 1) AS material#2968, cast(regexp_extract(value#6357, ^([A-Z].+) ([A-Z].+) was sold for (\\d+), 3) as int) AS price#2970]\n                     +- EventTimeWatermark timestamp#2961: timestamp, interval 10 seconds\n                        +- *(1) Project [value#6357, 1591296853427000 AS timestamp#2961]\n                           +- *(1) Project [value#6357]\n                              +- *(1) ScanV2 socket[value#6357] (Options: [host=0.0.0.0,port=9999])\n== Physical Plan ==\n*(5) HashAggregate(keys=[material#2968, timestamp#2967-T10000ms], functions=[avg(cast(price#2970 as bigint))])\n+- StateStoreSave [material#2968, timestamp#2967-T10000ms], state info [ checkpoint = file:/tmp/temporary-d53ac218-aad0-4a48-b4f8-f537542e449c/state, runId = 7b968f15-b723-436b-bc17-fc3d71577bd7, opId = 0, ver = 0, numPartitions = 200], Complete, 0, 2\n   +- *(4) HashAggregate(keys=[material#2968, timestamp#2967-T10000ms], functions=[merge_avg(cast(price#2970 as bigint))])\n      +- StateStoreRestore [material#2968, timestamp#2967-T10000ms], state info [ checkpoint = file:/tmp/temporary-d53ac218-aad0-4a48-b4f8-f537542e449c/state, runId = 7b968f15-b723-436b-bc17-fc3d71577bd7, opId = 0, ver = 0, numPartitions = 200], 2\n         +- *(3) HashAggregate(keys=[material#2968, timestamp#2967-T10000ms], functions=[merge_avg(cast(price#2970 as bigint))])\n            +- Exchange hashpartitioning(material#2968, timestamp#2967-T10000ms, 200)\n               +- *(2) HashAggregate(keys=[material#2968, timestamp#2967-T10000ms], functions=[partial_avg(cast(price#2970 as bigint))])\n                  +- *(2) Project [timestamp#2961-T10000ms AS timestamp#2967-T10000ms, regexp_extract(value#6361, ^([A-Z].+) ([A-Z].+) was sold for (\\d+), 1) AS material#2968, cast(regexp_extract(value#6361, ^([A-Z].+) ([A-Z].+) was sold for (\\d+), 3) as int) AS price#2970]\n                     +- EventTimeWatermark timestamp#2961: timestamp, interval 10 seconds\n                        +- *(1) Project [value#6361, 1591296853456000 AS timestamp#2961]\n                           +- *(1) Project [value#6361]\n                              +- *(1) ScanV2 socket[value#6361] (Options: [host=0.0.0.0,port=9999])\n"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769664_332330265",
      "id": "paragraph_1591048399196_1297874873",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "dateStarted": "2020-06-04T18:54:16+0000",
      "dateFinished": "2020-06-04T18:54:16+0000",
      "status": "FINISHED",
      "$$hashKey": "object:135"
    },
    {
      "text": "spark.sql(\"select * from rQ\").show(7,false)\nspark.sql(\"select * from rcQa\").show(7,false)\nspark.sql(\"select * from rcQc\").show(7,false)",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T18:54:54+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "+-----------------------+--------+------+\n|timestamp              |material|price |\n+-----------------------+--------+------+\n|2020-06-04 18:54:20.001|Dragon  |540213|\n|2020-06-04 18:54:20.001|Dragon  |719789|\n|2020-06-04 18:54:20.001|Dragon  |449571|\n|2020-06-04 18:54:20.001|Dragon  |570400|\n|2020-06-04 18:54:20.001|Mithril |299484|\n|2020-06-04 18:54:20.001|Dragon  |539392|\n|2020-06-04 18:54:20.001|Dragon  |719350|\n+-----------------------+--------+------+\nonly showing top 7 rows\n\n+-------------------+--------+------------------+\n|timestamp          |material|average           |\n+-------------------+--------+------------------+\n|2020-06-04 18:54:20|Mithril |349666.2638888889 |\n|2020-06-04 18:54:20|Dragon  |531635.7049180327 |\n|2020-06-04 18:54:20|Iron    |113474.23376623377|\n|2020-06-04 18:54:20|Adamant |392181.53225806454|\n|2020-06-04 18:54:20|Bronze  |58779.520547945205|\n|2020-06-04 18:54:20|Black   |230083.78431372548|\n|2020-06-04 18:54:20|White   |271103.8493150685 |\n+-------------------+--------+------------------+\nonly showing top 7 rows\n\n+-----------------------+--------+------------------+\n|timestamp              |material|average           |\n+-----------------------+--------+------------------+\n|2020-06-04 18:54:50    |Bronze  |56677.35294117647 |\n|2020-06-04 18:54:40.001|Bronze  |58075.77272727273 |\n|2020-06-04 18:54:20    |Mithril |330506.9428571428 |\n|2020-06-04 18:54:50    |Steel   |162945.4854368932 |\n|2020-06-04 18:54:50    |White   |283713.7931034483 |\n|2020-06-04 18:54:30    |Rune    |459327.9117647059 |\n|2020-06-04 18:54:30    |White   |277966.88181818184|\n+-----------------------+--------+------------------+\nonly showing top 7 rows\n\n"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {
        "jobUrl": {
          "propertyName": "jobUrl",
          "label": "SPARK JOB",
          "tooltip": "View in Spark web UI",
          "group": "spark",
          "values": [
            {
              "jobUrl": "http://7294e1d5edba:4040/jobs/job?id=1043",
              "$$hashKey": "object:3298"
            },
            {
              "jobUrl": "http://7294e1d5edba:4040/jobs/job?id=1044",
              "$$hashKey": "object:3299"
            },
            {
              "jobUrl": "http://7294e1d5edba:4040/jobs/job?id=1045",
              "$$hashKey": "object:3300"
            }
          ],
          "interpreterSettingId": "spark"
        }
      },
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769664_1657654711",
      "id": "paragraph_1591045648060_-1577789738",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "dateStarted": "2020-06-04T18:54:54+0000",
      "dateFinished": "2020-06-04T18:54:55+0000",
      "status": "FINISHED",
      "$$hashKey": "object:136"
    },
    {
      "text": "spark.sql(\"select count(*) as lines from rQ\").show()\nspark.sql(\"select count(*) as aBatches from rcQa\").show()\nspark.sql(\"select count(*) as cBatches from rcQc\").show()",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T19:00:02+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "+-----+\n|lines|\n+-----+\n|33981|\n+-----+\n\n+--------+\n|aBatches|\n+--------+\n|     297|\n+--------+\n\n+--------+\n|cBatches|\n+--------+\n|     315|\n+--------+\n\n"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {
        "jobUrl": {
          "propertyName": "jobUrl",
          "label": "SPARK JOB",
          "tooltip": "View in Spark web UI",
          "group": "spark",
          "values": [
            {
              "jobUrl": "http://7294e1d5edba:4040/jobs/job?id=1156",
              "$$hashKey": "object:3354"
            },
            {
              "jobUrl": "http://7294e1d5edba:4040/jobs/job?id=1157",
              "$$hashKey": "object:3355"
            },
            {
              "jobUrl": "http://7294e1d5edba:4040/jobs/job?id=1158",
              "$$hashKey": "object:3356"
            }
          ],
          "interpreterSettingId": "spark"
        }
      },
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769665_501686839",
      "id": "paragraph_1591047257507_1149293977",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "dateStarted": "2020-06-04T19:00:02+0000",
      "dateFinished": "2020-06-04T19:00:06+0000",
      "status": "FINISHED",
      "$$hashKey": "object:137"
    },
    {
      "text": "spark.sql(\"select timestamp,material,price from rQ where material=\\\"Rune\\\" order by timestamp desc\").show(7,false)",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T19:00:28+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/scala"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "+-------------------+--------+------+\n|timestamp          |material|price |\n+-------------------+--------+------+\n|2020-06-04 19:00:20|Rune    |586539|\n|2020-06-04 19:00:20|Rune    |586363|\n|2020-06-04 19:00:20|Rune    |505817|\n|2020-06-04 19:00:20|Rune    |587068|\n|2020-06-04 19:00:20|Rune    |425907|\n|2020-06-04 19:00:20|Rune    |613132|\n|2020-06-04 19:00:20|Rune    |560958|\n+-------------------+--------+------+\nonly showing top 7 rows\n\n"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {
        "jobUrl": {
          "propertyName": "jobUrl",
          "label": "SPARK JOB",
          "tooltip": "View in Spark web UI",
          "group": "spark",
          "values": [
            {
              "jobUrl": "http://7294e1d5edba:4040/jobs/job?id=1165",
              "$$hashKey": "object:3410"
            }
          ],
          "interpreterSettingId": "spark"
        }
      },
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591296032061_-1030819340",
      "id": "paragraph_1591296032061_-1030819340",
      "dateCreated": "2020-06-04T18:40:32+0000",
      "dateStarted": "2020-06-04T19:00:28+0000",
      "dateFinished": "2020-06-04T19:00:28+0000",
      "status": "FINISHED",
      "$$hashKey": "object:138"
    },
    {
      "text": "spark.sql(\"select timestamp,material,min(price),avg(price),max(price) from rQ where material=\\\"Rune\\\" group by timestamp,material order by timestamp desc\").show(7,false)\nspark.sql(\"select timestamp,material,average from rcQa where material=\\\"Rune\\\" order by timestamp desc\").show(7,false)\nspark.sql(\"select timestamp,material,average from rcQc where material=\\\"Rune\\\" order by timestamp desc\").show(7,false)",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T19:00:33+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {
          "0": {
            "graph": {
              "mode": "table",
              "height": 508,
              "optionOpen": false
            }
          }
        },
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/scala"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "+-----------------------+--------+----------+------------------+----------+\n|timestamp              |material|min(price)|avg(price)        |max(price)|\n+-----------------------+--------+----------+------------------+----------+\n|2020-06-04 19:00:30    |Rune    |265823    |451471.57657657657|640690    |\n|2020-06-04 19:00:20    |Rune    |266414    |456368.39344262297|641260    |\n|2020-06-04 19:00:10    |Rune    |266132    |443928.2016806723 |640570    |\n|2020-06-04 19:00:00    |Rune    |266235    |454963.11818181816|640194    |\n|2020-06-04 18:59:50.001|Rune    |265919    |472590.7731958763 |640791    |\n|2020-06-04 18:59:40    |Rune    |265942    |465420.3619047619 |641137    |\n|2020-06-04 18:59:30    |Rune    |266074    |452480.04132231406|640525    |\n+-----------------------+--------+----------+------------------+----------+\nonly showing top 7 rows\n\n+-------------------+--------+------------------+\n|timestamp          |material|average           |\n+-------------------+--------+------------------+\n|2020-06-04 19:00:10|Rune    |437304.5934065934 |\n|2020-06-04 19:00:00|Rune    |437347.14285714284|\n|2020-06-04 18:59:50|Rune    |458925.96078431373|\n|2020-06-04 18:59:40|Rune    |469715.91346153844|\n|2020-06-04 18:59:30|Rune    |444838.66964285716|\n|2020-06-04 18:59:20|Rune    |430439.9173553719 |\n|2020-06-04 18:59:10|Rune    |460010.2545454545 |\n+-------------------+--------+------------------+\nonly showing top 7 rows\n\n+-----------------------+--------+------------------+\n|timestamp              |material|average           |\n+-----------------------+--------+------------------+\n|2020-06-04 19:00:30.001|Rune    |448210.0882352941 |\n|2020-06-04 19:00:20    |Rune    |455917.9417475728 |\n|2020-06-04 19:00:10    |Rune    |425650.29411764705|\n|2020-06-04 19:00:00    |Rune    |460914.8611111111 |\n|2020-06-04 18:59:50    |Rune    |461391.12264150946|\n|2020-06-04 18:59:40    |Rune    |466698.94680851063|\n|2020-06-04 18:59:30    |Rune    |455650.7378640777 |\n+-----------------------+--------+------------------+\nonly showing top 7 rows\n\n"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {
        "jobUrl": {
          "propertyName": "jobUrl",
          "label": "SPARK JOB",
          "tooltip": "View in Spark web UI",
          "group": "spark",
          "values": [
            {
              "jobUrl": "http://7294e1d5edba:4040/jobs/job?id=1169",
              "$$hashKey": "object:3456"
            },
            {
              "jobUrl": "http://7294e1d5edba:4040/jobs/job?id=1170",
              "$$hashKey": "object:3457"
            },
            {
              "jobUrl": "http://7294e1d5edba:4040/jobs/job?id=1171",
              "$$hashKey": "object:3458"
            }
          ],
          "interpreterSettingId": "spark"
        }
      },
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591294766604_1231438863",
      "id": "paragraph_1591294766604_1231438863",
      "dateCreated": "2020-06-04T18:19:26+0000",
      "dateStarted": "2020-06-04T19:00:33+0000",
      "dateFinished": "2020-06-04T19:00:36+0000",
      "status": "FINISHED",
      "$$hashKey": "object:139"
    },
    {
      "text": "spark.streams.active",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T18:54:07+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "\u001b[1m\u001b[34mres185\u001b[0m: \u001b[1m\u001b[32mArray[org.apache.spark.sql.streaming.StreamingQuery]\u001b[0m = Array()\n"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769665_1008311513",
      "id": "paragraph_1591045650613_938589236",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "dateStarted": "2020-06-04T18:54:07+0000",
      "dateFinished": "2020-06-04T18:54:07+0000",
      "status": "FINISHED",
      "$$hashKey": "object:140"
    },
    {
      "text": "(rq.exception, rcqa.exception, rcqc.exception)",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T19:04:33+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "\u001b[1m\u001b[34mres213\u001b[0m: \u001b[1m\u001b[32m(Option[org.apache.spark.sql.streaming.StreamingQueryException], Option[org.apache.spark.sql.streaming.StreamingQueryException], Option[org.apache.spark.sql.streaming.StreamingQueryException])\u001b[0m = (None,None,None)\n"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769665_-1165206297",
      "id": "paragraph_1591048573228_-2077397308",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "dateStarted": "2020-06-04T19:04:33+0000",
      "dateFinished": "2020-06-04T19:04:33+0000",
      "status": "FINISHED",
      "$$hashKey": "object:141"
    },
    {
      "text": "(rq.lastProgress.batchId,rcqa.lastProgress.batchId,rcqc.lastProgress.batchId)",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T19:04:57+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {
          "0": {
            "graph": {
              "mode": "table",
              "height": 514,
              "optionOpen": false
            }
          }
        },
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "\u001b[1m\u001b[34mres219\u001b[0m: \u001b[1m\u001b[32m(Long, Long, Long)\u001b[0m = (64,64,64)\n"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769665_-2013894161",
      "id": "paragraph_1591049389433_1576232296",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "dateStarted": "2020-06-04T19:04:57+0000",
      "dateFinished": "2020-06-04T19:04:57+0000",
      "status": "FINISHED",
      "$$hashKey": "object:142"
    },
    {
      "text": "// Stop queries when done\nrq.stop()\nrcqa.stop()\nrcqc.stop()",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T19:05:09+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769665_-1237795011",
      "id": "paragraph_1591045840463_349762967",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "dateStarted": "2020-06-04T19:05:09+0000",
      "dateFinished": "2020-06-04T19:05:09+0000",
      "status": "FINISHED",
      "$$hashKey": "object:143"
    },
    {
      "text": "%md\nAgain, mind the lazy Spark evaluation!\nWe setup a streaming query plan `r` to get our `RuneData` out of the socket in a streaming fashion. \n\nLike above, start a query that streams to console, let it run for a while, and look at the output when you stop the query or investigate state in between:",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Again, mind the lazy Spark evaluation!<br />\nWe setup a streaming query plan <code>r</code> to get our <code>RuneData</code> out of the socket in a streaming fashion.</p>\n<p>Like above, start a query that streams to console, let it run for a while, and look at the output when you stop the query or investigate state in between:</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769666_1416596013",
      "id": "paragraph_1590366295075_-1846777262",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:144"
    },
    {
      "text": "val rConsoleQuery = runes\n  .writeStream\n  .outputMode(\"append\")\n  .format(\"console\")\n  .start()",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769666_2111424720",
      "id": "paragraph_1590366302193_1646148825",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:145"
    },
    {
      "text": "spark.streams.active",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769666_1508813704",
      "id": "paragraph_1590366560008_-96132883",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:146"
    },
    {
      "text": "rConsoleQuery.stop()",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769666_-1474021751",
      "id": "paragraph_1590366322745_-432112087",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:147"
    },
    {
      "user": "anonymous",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": false,
        "results": {},
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/text",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591524298738_587791744",
      "id": "paragraph_1591524298738_587791744",
      "dateCreated": "2020-06-07T10:04:58+0000",
      "status": "FINISHED",
      "focus": true,
      "$$hashKey": "object:5554",
      "text": "%md \n## Ingestion Time Timestamps\n\nSocket readers can also timestamp the data on ingestion time using the `includeTimestamp` option.",
      "dateUpdated": "2020-06-07T10:06:33+0000",
      "dateFinished": "2020-06-07T10:06:31+0000",
      "dateStarted": "2020-06-07T10:06:31+0000",
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h2>Ingestion Time Timestamps</h2>\n<p>Socket readers can also timestamp the data on ingestion time using the <code>includeTimestamp</code> option.</p>\n\n</div>"
          }
        ]
      }
    },
    {
      "text": "// include ingestion time timestamp\nval tsocketDF = spark.readStream\n  .format(\"socket\")\n  .option(\"host\", \"0.0.0.0\")\n  .option(\"port\", 9999)\n  .option(\"includeTimestamp\", true)\n  .load()",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T10:04:52+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true,
        "editorHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "\u001b[1m\u001b[34mtsocketDF\u001b[0m: \u001b[1m\u001b[32morg.apache.spark.sql.DataFrame\u001b[0m = [value: string, timestamp: timestamp]\n"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591302396881_677556418",
      "id": "paragraph_1591302396881_677556418",
      "dateCreated": "2020-06-04T20:26:36+0000",
      "dateStarted": "2020-06-07T10:04:52+0000",
      "dateFinished": "2020-06-07T10:04:52+0000",
      "status": "FINISHED",
      "$$hashKey": "object:148"
    },
    {
      "text": "%md\nSocket readers can also timestamp the data on ingestion time.",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T20:36:34+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": false,
        "results": {},
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/text",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Socket readers can also timestamp the data on ingestion time.</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591302949737_1520971277",
      "id": "paragraph_1591302949737_1520971277",
      "dateCreated": "2020-06-04T20:35:49+0000",
      "dateStarted": "2020-06-04T20:36:18+0000",
      "dateFinished": "2020-06-04T20:36:18+0000",
      "status": "FINISHED",
      "$$hashKey": "object:149"
    },
    {
      "text": "tsocketDF\n  .withWatermark(\"timestamp\",\"10 seconds\")\n  .createOrReplaceTempView(\"runeUpdatesDF\")\n  \nspark.sql(q).as[RuneData].createOrReplaceTempView(\"runes\")\n\nval rtq  = spark.sql(\"select timestamp, material, price from runes\")\n    .writeStream\n    .outputMode(\"append\")\n    .format(\"memory\")\n    .queryName(\"rtQ\")\n    .trigger(Trigger.ProcessingTime(\"10 seconds\"))\n    .start()\n    \nval rtpq = spark.sql(\"select material, window(timestamp, \\\"5 seconds\\\"), sum(price) as matcost from runes group by window(timestamp,\\\"5 seconds\\\"), material\")\n    .writeStream\n    .outputMode(\"update\")\n    .format(\"memory\")\n    .queryName(\"rtpQ\")\n    .trigger(Trigger.ProcessingTime(\"10 seconds\"))\n    .start()",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T10:26:42+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true,
        "editorHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "\u001b[1m\u001b[34mrtq\u001b[0m: \u001b[1m\u001b[32morg.apache.spark.sql.streaming.StreamingQuery\u001b[0m = org.apache.spark.sql.execution.streaming.StreamingQueryWrapper@1cf25bb6\n\u001b[1m\u001b[34mrtpq\u001b[0m: \u001b[1m\u001b[32morg.apache.spark.sql.streaming.StreamingQuery\u001b[0m = org.apache.spark.sql.execution.streaming.StreamingQueryWrapper@1f2a66a\n"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591302492600_865932219",
      "id": "paragraph_1591302492600_865932219",
      "dateCreated": "2020-06-04T20:28:12+0000",
      "dateStarted": "2020-06-07T10:26:42+0000",
      "dateFinished": "2020-06-07T10:26:42+0000",
      "status": "FINISHED",
      "$$hashKey": "object:150"
    },
    {
      "text": "// Rune price over time\nspark.sql(\"select timestamp,material,price from rtQ where material=\\\"Rune\\\" order by timestamp desc\").show(3,false)\n\n// Rune price aggregates over time\n// spark.sql(\"select timestamp,material,min(price),avg(price),max(price) from rtQ where material=\\\"Rune\\\" group by timestamp,material order by timestamp desc\").show(7,false)\n\n// Most expensive material\nspark.sql(\"select * from rtpQ order by matcost desc\").show(7,false)",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T11:14:57+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {
          "0": {
            "graph": {
              "mode": "table",
              "height": 453.3,
              "optionOpen": false
            }
          }
        },
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/scala",
        "editorHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "+-----------------------+--------+------+\n|timestamp              |material|price |\n+-----------------------+--------+------+\n|2020-06-07 10:28:09.839|Rune    |401151|\n|2020-06-07 10:28:09.815|Rune    |532770|\n|2020-06-07 10:28:09.693|Rune    |480058|\n+-----------------------+--------+------+\nonly showing top 3 rows\n\n+--------+------------------------------------------+--------+\n|material|window                                    |matcost |\n+--------+------------------------------------------+--------+\n|Dragon  |[2020-06-07 10:27:20, 2020-06-07 10:27:25]|35915026|\n|Dragon  |[2020-06-07 10:27:30, 2020-06-07 10:27:35]|35843709|\n|Rune    |[2020-06-07 10:27:35, 2020-06-07 10:27:40]|30905516|\n|Dragon  |[2020-06-07 10:27:50, 2020-06-07 10:27:55]|29875533|\n|Rune    |[2020-06-07 10:26:55, 2020-06-07 10:27:00]|29305881|\n|Dragon  |[2020-06-07 10:27:45, 2020-06-07 10:27:50]|28289241|\n|Dragon  |[2020-06-07 10:27:15, 2020-06-07 10:27:20]|27607030|\n+--------+------------------------------------------+--------+\nonly showing top 7 rows\n\n"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {
        "jobUrl": {
          "propertyName": "jobUrl",
          "label": "SPARK JOB",
          "tooltip": "View in Spark web UI",
          "group": "spark",
          "values": [
            {
              "jobUrl": "http://7294e1d5edba:4040/jobs/job?id=1531",
              "$$hashKey": "object:8621"
            },
            {
              "jobUrl": "http://7294e1d5edba:4040/jobs/job?id=1532",
              "$$hashKey": "object:8622"
            }
          ],
          "interpreterSettingId": "spark"
        }
      },
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591302859007_-1008570002",
      "id": "paragraph_1591302859007_-1008570002",
      "dateCreated": "2020-06-04T20:34:19+0000",
      "dateStarted": "2020-06-07T11:14:57+0000",
      "dateFinished": "2020-06-07T11:14:57+0000",
      "status": "FINISHED",
      "$$hashKey": "object:151"
    },
    {
      "text": "// Stop the two queries\n(rtq.stop(), rtpq.stop())",
      "user": "anonymous",
      "dateUpdated": "2020-06-07T14:52:25+0000",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/scala"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TEXT",
            "data": "\u001b[1m\u001b[34mres285\u001b[0m: \u001b[1m\u001b[32m(Unit, Unit)\u001b[0m = ((),())\n"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591302928758_-152583895",
      "id": "paragraph_1591302928758_-152583895",
      "dateCreated": "2020-06-04T20:35:28+0000",
      "dateStarted": "2020-06-07T14:52:25+0000",
      "dateFinished": "2020-06-07T14:52:26+0000",
      "status": "FINISHED",
      "$$hashKey": "object:152"
    },
    {
      "user": "anonymous",
      "config": {
        "colWidth": 12,
        "fontSize": 9,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/scala"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591525127179_-392815990",
      "id": "paragraph_1591525127179_-392815990",
      "dateCreated": "2020-06-07T10:18:47+0000",
      "status": "FINISHED",
      "focus": true,
      "$$hashKey": "object:5887",
      "text": "// Stop all running queries\nfor (q <- spark.streams.active) q.stop()",
      "dateUpdated": "2020-06-07T14:52:00+0000",
      "dateFinished": "2020-06-07T14:52:01+0000",
      "dateStarted": "2020-06-07T14:52:00+0000",
      "results": {
        "code": "SUCCESS",
        "msg": []
      }
    },
    {
      "text": "%md\n## Writing output to disk\n\nIn a more realistic streaming setup, we would not write our output to the console. \n\nWith Spark Structured Streaming, it is almost trivial to stream the query output straight into the filesystem, into Parquet files ready for further analysis. First, create a directory into which we will write out the data we sample from the stream.",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h2>Writing output to disk</h2>\n<p>In a more realistic streaming setup, we would not write our output to the console.</p>\n<p>With Spark Structured Streaming, it is almost trivial to stream the query output straight into the filesystem, into Parquet files ready for further analysis. First, create a directory into which we will write out the data we sample from the stream.</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769667_134425343",
      "id": "paragraph_1589452249641_515522795",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:153"
    },
    {
      "text": "%sh\nmkdir -p /bigdata",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "sh",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/sh",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": []
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769667_-612461502",
      "id": "paragraph_1589449045934_-244136830",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:154"
    },
    {
      "text": "%md\nSetup another writer to copy the query output to disk.",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "tableHide": false,
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Setup another writer to copy the query output to disk.</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769667_-161992075",
      "id": "paragraph_1589452477092_-586340868",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:155"
    },
    {
      "text": "val streamWriterDisk = runes\n  .writeStream\n  .outputMode(\"append\")\n  .option(\"checkpointLocation\", \"/tmp/checkpoint\")\n  .trigger(Trigger.ProcessingTime(\"2 seconds\"))",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769667_1760150884",
      "id": "paragraph_1589451076971_191695654",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:156"
    },
    {
      "text": "%md\nReady?\n\nThen start the query!",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Ready?</p>\n<p>Then start the query!</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769667_-1551032048",
      "id": "paragraph_1590370516708_-1662229510",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:157"
    },
    {
      "text": "val stream2disk = streamWriterDisk\n  .start(\"/bigdata\")",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "editorHide": false,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769668_2024717632",
      "id": "paragraph_1590343545514_1652541639",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:158"
    },
    {
      "text": "%md\nIf all worked out well, the following command lists a running streaming query (in a Scala Array).",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>If all worked out well, the following command lists a running streaming query (in a Scala Array).</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769668_263132316",
      "id": "paragraph_1590368943647_587099821",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:159"
    },
    {
      "text": "spark.streams.active",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769668_1905283920",
      "id": "paragraph_1590367515865_536586416",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:160"
    },
    {
      "text": "%md\nIn case of missing output or other reasons to suspect an error, check the streaming query's exception state:",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>In case of missing output or other reasons to suspect an error, check the streaming query&rsquo;s exception state:</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769668_-828883216",
      "id": "paragraph_1590368877516_1943440320",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:161"
    },
    {
      "text": "stream2disk.exception",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769668_2099216236",
      "id": "paragraph_1590368773239_1239609256",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:162"
    },
    {
      "text": "%md\nSlowly but steadily, your disk may fill up:",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Slowly but steadily, your disk may fill up:</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769669_-1814111767",
      "id": "paragraph_1590369939018_46179868",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:163"
    },
    {
      "text": "%sh\ndu --si /bigdata",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "sh",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/sh",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769669_-970802637",
      "id": "paragraph_1590332129421_792210783",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:164"
    },
    {
      "text": "// Stop the stream after a while;\n// for example, when say when you collected a few megabytes of data:\nstream2disk.stop()",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769669_-165230590",
      "id": "paragraph_1590369941493_1881016502",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:165"
    },
    {
      "text": "%md\nCheckpointing is what is needed for fault-tolerance in an operational streaming setting. I'd be happy if you'd dive into it, but it's ok for now to just take that for granted. Roughly, because we defined a trigger on this query, every other second a checkpoint should have been created, and a microbatch written to disk.",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<p>Checkpointing is what is needed for fault-tolerance in an operational streaming setting. I&rsquo;d be happy if you&rsquo;d dive into it, but it&rsquo;s ok for now to just take that for granted. Roughly, because we defined a trigger on this query, every other second a checkpoint should have been created, and a microbatch written to disk.</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769669_-1447662519",
      "id": "paragraph_1590342468854_82445142",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:166"
    },
    {
      "text": "%sh\necho \"Checkpoints: $(eval ls /bigdata | wc -l)\"",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "sh",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "colWidth": 12,
        "editorMode": "ace/mode/sh",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769669_1571009435",
      "id": "paragraph_1589453278436_-2041112869",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:167"
    },
    {
      "text": "%md\n## Working with the data collected\nWe can open the sample that was written to disk for analysis using the Dataframe API like we did in assignment 3B. Consider for example a few aggregate queries to produce average price over all items of a certain material, or the minimum or maximum price paid in an transaction.",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h2>Working with the data collected</h2>\n<p>We can open the sample that was written to disk for analysis using the Dataframe API like we did in assignment 3B. Consider for example a few aggregate queries to produce average price over all items of a certain material, or the minimum or maximum price paid in an transaction.</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769670_1544422142",
      "id": "paragraph_1589453362862_-465527225",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:168"
    },
    {
      "text": "val runes = spark.\n  .read\n  .parquet(\"/bigdata/part-*\")\n  .createOrReplaceTempView(\"runes\")",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769670_-1527690128",
      "id": "paragraph_1589447453688_-947324524",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:169"
    },
    {
      "text": "spark.sql(\"SELECT material, avg(price) FROM runes GROUP BY material\").show()",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769670_480972592",
      "id": "paragraph_1590367616021_552396401",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:170"
    },
    {
      "text": "spark.sql(\"SELECT min(price), max(price) FROM runes\").show()",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/scala",
        "fontSize": 9,
        "results": {},
        "enabled": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769670_-768169780",
      "id": "paragraph_1590374447162_-1852692101",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:171"
    },
    {
      "text": "%md\n## Next steps\n\nYou have reached the point where the initiative is yours; time for some creativity!\n\nTry to create your own dashboard, that you might have used to take decisions in the original game.\nAt the minimum, write code to answer the following questions:\n\n- How many rune items were sold?\n- How many of each item type was sold?\n- How much gold was spent buying swords?\n\nIn the previous step however, we wrote the individual transactions to disk and then carried out analyses using static dataframes. Can you get (one or more of these) other interesting properties of the stream to be updated per microbatch (instead of being run on the full dataset loaded into the cluster)?\n\nCan you think of related queries, or have a go at an even more advanced report that is continuously updated?\n\nI am looking forward to reading about your results in the A5 blog posts!",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h2>Next steps</h2>\n<p>You have reached the point where the initiative is yours; time for some creativity!</p>\n<p>Try to create your own dashboard, that you might have used to take decisions in the original game.<br />\nAt the minimum, write code to answer the following questions:</p>\n<ul>\n<li>How many rune items were sold?</li>\n<li>How many of each item type was sold?</li>\n<li>How much gold was spent buying swords?</li>\n</ul>\n<p>In the previous step however, we wrote the individual transactions to disk and then carried out analyses using static dataframes. Can you get (one or more of these) other interesting properties of the stream to be updated per microbatch (instead of being run on the full dataset loaded into the cluster)?</p>\n<p>Can you think of related queries, or have a go at an even more advanced report that is continuously updated?</p>\n<p>I am looking forward to reading about your results in the A5 blog posts!</p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769670_-300409206",
      "id": "paragraph_1589447952519_-1056716615",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:172"
    },
    {
      "text": "%md\n\n## In case of despair...\n\nIf you get stuck, try the following:\n\n```\ndocker stop snbz\ndocker start snbz\ndocker exec snbz sh -c \"python stream.py &\"\n```\n\nCheck the logs for obvious error notifications or warnings:\n\n```\ndocker logs snbz\n```\n\nCheck state of files/directories/etc. inside the container:\n\n```\ndocker exec -it snbz /bin/bash\n```\n\nE.g., remove incomplete state from a previous failed attempt:\n\n```\nrm -rf /bigdata /tmp/checkpoint*\n```\n\nStill no luck after checking all of these?\nCome see us for help at the Forum and/or the Matrix room.\n\n_Good luck with the assignment!_",
      "user": "anonymous",
      "dateUpdated": "2020-06-04T16:22:49+0000",
      "config": {
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "colWidth": 12,
        "editorMode": "ace/mode/text",
        "fontSize": 9,
        "editorHide": true,
        "results": {},
        "enabled": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "<div class=\"markdown-body\">\n<h2>In case of despair&hellip;</h2>\n<p>If you get stuck, try the following:</p>\n<pre><code>docker stop snbz\ndocker start snbz\ndocker exec snbz sh -c &quot;python stream.py &amp;&quot;\ndocker logs snbz\n</code></pre>\n<p>Check if things look alright inside the container:</p>\n<pre><code>docker exec -it snbz /bin/bash\n</code></pre>\n<p>Remove state from a previous failed attempt:</p>\n<pre><code>rm -rf /bigdata /tmp/checkpoint*\n</code></pre>\n<p>Still no luck after checking all of these?<br />\nCome see us for help at the Forum and/or the Matrix room.</p>\n<p><em>Good luck with the assignment!</em></p>\n\n</div>"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1591287769671_-1267096226",
      "id": "paragraph_1590371520582_267448686",
      "dateCreated": "2020-06-04T16:22:49+0000",
      "status": "READY",
      "$$hashKey": "object:173"
    }
  ],
  "name": "Spark Streaming",
  "id": "2FC4GYBWU",
  "defaultInterpreterGroup": "spark",
  "version": "0.9.0-preview1",
  "noteParams": {},
  "noteForms": {},
  "angularObjects": {},
  "config": {
    "isZeppelinNotebookCronEnable": false,
    "looknfeel": "default",
    "personalizedMode": "false"
  },
  "info": {},
  "path": "/Spark Streaming"
}